1. url = http 프로토콜 + 도메인 이름 + 파일 경로/페이지 경로

------------------------------------------------------------------------------------------------------------------------

2. 웹 호스팅이란 호스팅 회사의 웹 서버에 DB, 웹사이트 코드, email을 배치하는 서비스이다
ip주소는 우편 주소와 흡사하다. 우편 주소가 없으면 편지를 받지 못한다

인터넷을 통해 컴퓨터간 데이터 송수신을 가능하게 하는 것은 인터넷 프로토콜이다 (IV4, IV6이 현재 표준)
iv4에서 ip주소는 4개의 옥텟으로 구성된다 (148.201,164.3)

------------------------------------------------------------------------------------------------------------------------

3. TCP(Transmission Control Protocol)는 데이터를 안전, 정확하게 송신
  빈 부분을 다시 보내달라고 요청해서 데이터가 정확하게 전송되는 것을 보장해준다. (이메일이나 웹 페이지)
   UDP(User Datagram Protocol)는 빠르게 보내지만, 중간에 손실되거나 순서가 뒤바뀔 수 있다, 그래도 괜찮은 경우에 사용.
    (실시간 비디오나 음성 채팅)

------------------------------------------------------------------------------------------------------------------------

4. HTTP는 웹페이지, 이미지, 동영상 및 기타 파일 같은 웹 리소스를 전송하는 데 사용되는 요청 응답 기반 프로토콜이다.

http 요청의 구성

예시
```
GET / HTTP / 1.1
HOST: developer.mozilla.org
Accept-Language: en
```
GET : 지정된 서버에서 정보를 검색하는 데 사용
POST : 데이터를 서버로 전송함
PUT : 웹 서버에 존재하는 모든 항목을 다른 것으로 업데이트
DELETE : 리소스 제거

http 응답의 구성
예시
```
HTTP/1.1 200 OK
Date: Sun, 31 Dec 2023 12:00:00 GMT
Server: Apache/2.4.1 (Unix)
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: “51142bc1-7449-479b075b2891b”
Content-Type: text/html; charset=UTF-8
Content-Length: 1234

(메시지 본문)
<html>
<body>
  <h1>Hello, World!</h1>
</body>
</html>

```
Informational(정보) 100-199
Successful(성공) 200-299
Redirection 300-399 요청된 리소스가 다른 경로로 이동되었음
301, 302가 일반적이며
301은 일시적 이동이며 브라우저는 리소스에 대한 요청을 자동으로 제출
302는

Client Error 400-499
400 : 클라이언트가 잘못된 데이터를 웹 서버에 제출한 경우
401 : 클라이언트가 계정에 로그인해야만 요청을 처리할 수 있는 경우
403 : 요청이 유효하나 웹 서버가 권한 등의 문제로 처리를 거부함
404 : 요청 리소스가 웹 서버에서 발견되지 않음
Server Error 500-599

------------------------------------------------------------------------------------------------------------------------

5. 웹 어플리케이션 : 상호작용 수준과 동적 컨텐츠의 양이 웹 사이트에 비해 월등히 많을 때
웹 사이트는 더 많은 정보를 제공하고, 웹앱은 더 인터랙티브하다

------------------------------------------------------------------------------------------------------------------------

6. 프레임워크와 라이브러리의 개요 :
프레임워크 : 개발자가 빌드할 수 있는 구조를 제공한다 (프레임워크가 먼저 있고, 개발자가 그 안에 코드를 작성)
라이브러리 : 애플리케이션에서 재사용 가능한 (특정 기능을 제공하는) 코드의 모음 [이메일 주소 확인 등의 표준 기능들을 애써 만들 필요가 없다]

------------------------------------------------------------------------------------------------------------------------

7. API :
API : 애플리케이션 프로그래밍 인터페이스, 앱 또는 기타 서비스의 기능/데이터에 액세스하는 앱을 만들기 위한 일련의 함수 및 프로시저이다
API는 실제로 시스템간 브리지 역할을 하기 때문에 게이트웨이 또는 미들웨어라고도 한다

Browser API : 새 서비스를 추가해 브라우저의 기능 확장
		-DOM API : html 문서를 자바스크립트 객체로 표현되는 노드 트리로 변환함

REST API : 인기 있는 웹앱, 모바일 앱에 데이터를 제공한다 (요청에 대한 응답)

API는 엔드포인트를 사용해 다양한 리소스에 액세스할 수 있는 방법을 지정한다. 엔드포인트는 API에 액세스할 때 URL에 내장된다.
엔드포인트에 도달하면 API는 응답을 작성하는 데 필요한 모든 서비스 처리를 수행한다.

응답의 형태는 크게 두 가지로 나뉘는데, full html과 JSON(자바스크립트 기반 데이터 양식)이다
Sensor-Based API : 사물인터넷의 기반

------------------------------------------------------------------------------------------------------------------------

8. HTML :

하이퍼텍스트는 다른 텍스트로 연결되는 링크를 포함한 텍스트이다.

마크업은 문서 내에서 사용되는 태그와 요소를 말한다

form

클라이언트가 웹 사이트에 데이터를 입력할 때 html양식은 데이터가 포함된 http요청을 서버에 제출한다

<form action=“/registration” method=“POST”>
</form>
action은 요청을 제출해야 하는 url을 지정, 지정되지 않으면 현재 웹 페이지와 동일한 경로로 요청이 제출된다

http method는 http 요청 방식을 결정한다
GET = 서버에서 정보 검색
POST = 데이터를 서버로 보냄

<input type=“submit” />은 양식 내용을 포함한 http요청을 웹 서버로 전송시킨다.

------------------------------------------------------------------------------------------------------------------------

9. DOM :
웹 브라우저가 html 페이지를 수신하면 해당 페이지를 나타내는 DOM을 구성한다

dom은 html파일 내의 개체 트리 구조(모델)이다
html의 모든 요소는 문서 개체 모델의 개체로 표시된다

html
	head
		title
	body
		h1

개발자는 DOM에 액세스, 수정하여 웹 페이지를 동적으로 만들 수 있다

------------------------------------------------------------------------------------------------------------------------

10. 웹 접근성 :

웹 접근성

보편성, 장애를 가진 사람들이 웹사이트를 탐색, 상호작용 할 수 있도록 하는 것을 목표로 한다

content -> padding -> border -> margin

100px -> 10px -> 10px -> 10px일 때 border 박스의 크기는

 = 140px

Block : 부모 요소의 전체 내용의 가로 세로를 차지한다. 각 블록 요소에는 앞뒤에 새 줄이 생긴다.

inline : 콘텐츠의 너비, 높이만 차지한다

두 개의 차이점을 정리하자면, inline은 다른 요소와 같은 줄에 배치되면서 내용의 크기에 따라 크기가 결정되고, block은 새로운 줄에서 시작해 가능한 모든 너비를 차지하며, 너비와 높이를 조절할 수 있다

------------------------------------------------------------------------------------------------------------------------

11. 라이브러리(의존성)
내가 짠 코드는 라이브러리/프레임워크에서 제공하는 API와 상호 작용한다

최종적인 목적은 배포이므로, 라이브러리/프레임워크 또한 웹 서버에 포함된다. 즉, 없으면 정지되는 기능이 많으므로 종속된다

이 때문에 JSON에 들어가는 패키지들을 디펜던시(종속성)라는 그룹으로 묶는다

패키지 매니저(npm)은 종속성 문제 없이 api를 사용하게 해준다

이후 다운로드 받은 디펜던시를 html파일에 포함시킨다.

하지만 모든 파일을 html파일에 추가하면 시간이 오래 걸리므로, 번들링 툴을 이용한다. 번들링은 웹 리소스를 하나의 단일 파일로 결합시킨다.

번들 크기가 커지면 종속성을 여러 번들로 분할도 가능하다 (Webpack 사용)

반응형 디자인은

flexible 그리드

fluid 이미지 (이미지에 max-width:100%를 줘서, 어느 부분에 들어가던지 알맞게 맞춰짐.)

미디어 쿼리

이 세 가지의 조합으로 이루어진다

유연한 그리드: 이 방법은 웹 페이지의 요소들을 백분율로 정의하여 화면 크기에 따라 자동으로 조정된다. 기둥, 거터, 여백을 포함하는데, 여기서 거터는 열 사이의 공간, 여백은 콘텐츠와 화면 가장자리 사이의 공간을 의미한다.

유연한 이미지: 이미지의 CSS '최대 너비' 속성을 100%로 설정하여 화면 크기에 따라 자연스럽게 축소될 수 있게 한다. 이 방법은 이미지가 열 너비보다 커지지 않도록 하여 오버플로를 방지한다.

미디어 쿼리: CSS의 한 부분으로, 화면의 크기, 방향, 해상도 등에 따라 다른 스타일 규칙을 적용할 수 있게 해준다. 예를 들어, 화면 크기가 특정 값 이하일 때 다른 배경색을 적용하는 것 등이 가능하다.

반응형 디자인은 또한 중단점을 사용하여 다양한 화면 크기에 맞게 콘텐츠와 레이아웃을 조정한다.

고정 그리드는 특정 중단점에서 내용이 변하지 않는 반면,

유동 그리드는 사용 가능한 공간에 맞게 요소의 크기를 조정한다.

하이브리드 그리드는 유동적인 폭과 고정된 구성요소를 결합한 방식이다.


| Breakpoint (중단점) | Class Infix (클래스 인픽스) | Dimensions (차원) |
|-------------------|--------------------------|-----------------|
| Extra small (<576px) | None (디폴트 중단점이라서 접미사 없음) | Width < 576px |
| Small (≥576px) | sm | Width ≥ 576px |
| Medium (≥768px) | md | Width ≥ 768px |
| Large (≥992px) | lg | Width ≥ 992px |
| Extra large (≥1200px) | xl | Width ≥ 1200px |
| Extra extra large (≥1400px) | xxl | Width ≥ 1400px |

이 표는 Bootstrap의 반응형 그리드 시스템에서 사용되는 주요 중단점, 해당 중단점을 지정할 때 사용되는 클래스 인픽스, 그리고 각 중단점에 해당하는 화면 크기의 차원을 보여준다. 예를 들어, `sm` 인픽스를 사용하는 클래스는 화면 너비가 576픽셀 이상일 때 적용된다.

------------------------------------------------------------------------------------------------------------------------

12. 정적 / 동적 컨텐츠와 웹, 애플리케이션 서버

정적 컨텐츠 : 비디오나 이미지처럼 웹 서버에 저장된 데이터가 그대로 전송된다

동적 컨텐츠 : http요청이 이루어질 때 생성된다. 사용자 입력/프로필 기반의 컨텐츠나 날짜에 따른 뉴스 컨텐츠가 있다.

애플리케이션 서버는 웹 서버가 사용자의 브라우저로 재응답하는 동적 컨텐츠를 생성한다

동적 컨텐츠는 정적 컨텐츠보다 생성시간이 길다. 애플리케이션 서버는 웹 서버보다 더 복잡한 처리를 수행한다.

웹 서버는 모든 요청에 대해 동적으로 콘텐츠를 생성하는 대신, 캐싱이라는 프로세스를 사용한다
캐싱이란 웹 서버가 동적 컨텐츠의 사본을 보관하는 것을 의미한다.
콘텐츠가 재요청될 경우 웹 서버는 요청을 애플리케이션 서버에 전달하는 대신, 캐시된 버전을 즉시 전송한다.

첫 요청 시,
웹 서버는 콘텐츠가 캐시에 있는지 확인 ->
캐시에 없다면 애플리케이션 서버에 콘텐츠를 요청해 캐시에 저장 ->
저장된 동적 컨텐츠를 브라우저로 전송 ->
후속 요청이 오면 캐시에서 다시 전송

------------------------------------------------------------------------------------------------------------------------

13. SPA (Single Page Application)

이전의 웹사이트 : 모든 요청에 대한 전체 웹 페이지 전송으로 과도한 대역폭 소비, CPU 리소스 과소비, 좋지 않은 UX.

SPA :
서버에서 / HTML 페이지 / 전송
사용자 상호 작용 / 동적으로 업데이트 / UX 향상
전체 웹 페이지 다운로드 없이 / 필요한 부분만 업데이트 / 애플리케이션 반응성 향상.

뷰라고 하는 각 템플릿에 업데이트 할 수 있는 Html코드가 분할되어 있어서 웹 서버에서 JSON 객체를 보내 페이지를 업데이트한다

로딩 방식 )

번들링 :

필요한 모든 html, css, js 한 번에 로드 / 미리 로드 / 큰 크기로 인해 지연될 수도 있음

지연 로딩/코드 분할 :
최소 리소스만 초기 로드 / 요청에 따른 추가 리소스 / 로드 시간 단축

React를 사용하는 이유

코드의 유지보수가 용이함
간소한 테스트
서드파티를 통한 확장성(React native)

유저프로필의 모든 인스턴스에 대한 로직을 짜는 대신 프로필 사진을 사용할 때마다 버전을 표시하는 사용자 아이콘 컴포넌트를 만들 수 있다

------------------------------------------------------------------------------------------------------------------------

14. React

간단한 업데이트 과정: 데이터가 시간에 따라 변할 때 React의 진가가 드러납니다. 전통적인 JavaScript 애플리케이션은 데이터 변경을 수동으로 DOM에 적용해야 하지만, React는 컴포넌트의 render 메소드를 통해 효율적인 방식으로 DOM 업데이트를 수행합니다. 이 과정을 우리는 '재조정(reconciliation)'이라고 부릅니다.

HTML 너머의 가능성: React는 문서의 가벼운 표현을 자체적으로 가지고 있어, 다양한 방식으로 활용할 수 있습니다. 예를 들어, Facebook은 HTML 대신 <canvas>로 렌더링하는 동적 차트를, Instagram은 React와 Backbone.Router를 사용하여 구축된 "단일 페이지" 웹 앱입니다. 또한, 서버에서 React를 실행하여 SEO, 성능, 코드 공유, 전반적인 유연성을 향상시킬 수 있습니다.

일관된 이벤트 처리: React의 이벤트는 모든 브라우저에서 일관되고 표준에 부합하는 방식으로 동작하며, 자동으로 이벤트 위임을 사용합니다.

React는 가상 DOM의 HTML 요소가 브라우저 DOM과 일치하는지 확인하고, 변경이 필요한 경우에만 브라우저 DOM을 업데이트합니다. 이 과정을 '조정(reconciliation)'이라고 합니다. React는 가상 DOM을 이전 버전과 비교하여 어떤 요소가 변경되었는지 확인하고, 변경된 요소만 브라우저 DOM에서 업데이트하여 웹 페이지를 변경합니다.

1) 가상 DOM 업데이트, 2) 변경된 요소 확인을 위한 가상 DOM 비교, 3) 변경된 요소의 브라우저 DOM 업데이트, 4) 웹 페이지의 표시 업데이트. 이 과정은 불필요한 브라우저 DOM 업데이트를 줄여 성능을 개선합니다.

하지만 많은 요소가 업데이트될 때는 여전히 비용이 많이 들고 성능 저하를 일으킬 수 있습니다. 이 문제를 해결하기 위해 React 팀은 연구를 진행했고, 그 결과로 'React Fiber Architecture'가 탄생했습니다. 이 구조는 React가 웹 페이지를 점진적으로 렌더링할 수 있게 해, 가상 DOM 변경 사항을 시간에 걸쳐 분산시킵니다. 이는 우선순위 시스템처럼 작동하여 사용자에게 보이는 고우선순위 변경 사항을 먼저 업데이트하고, 현재 표시되지 않는 저우선순위 변경 사항은 나중에 업데이트합니다.

Lodash: 일반적인 개발 작업을 단순화하는 유틸리티 라이브러리입니다. 리스트 정렬이나 숫자 반올림과 같은 흔한 로직을 제공합니다.

Luxon: 날짜와 시간을 다루는 데 유용한 라이브러리입니다. 다양한 국가의 날짜 형식에 맞게 날짜와 시간을 조작하고 표시하는 함수를 제공합니다.

Redux: 웹 애플리케이션의 상태 관리를 돕는 라이브러리입니다. 쇼핑 카트의 아이템 추적 같은 상태 변경을 관리하며, 되돌리기 및 다시 실행과 같은 고급 기능도 지원합니다.

Axios: HTTP를 통해 API와 통신할 때 사용하는 라이브러리입니다. HTTP 요청을 보내고 응답을 처리하는 과정을 단순화하며, 요청 취소나 서버로부터 받은 데이터 변경과 같은 고급 기능을 제공합니다.

Jest: 코드를 자동 테스트하는 것은 좋은 개발 습관입니다. Jest는 다양한 라이브러리 및 프레임워크와 함께 작동하며, 코드의 어느 부분이 자동 테스트에 의해 검증되었는지 알려주는 보고 기능도 제공합니다.

jquery의 등장배경 : 다양한 브라우저들이 난무하던 2000년대 초 호환성 문제를 해결하기 위해 등장, 그러나 시간이 지나며 잘 쓰이지 않음.





